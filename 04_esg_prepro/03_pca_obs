# -*- coding: utf-8 -*-
"""
PIPELINE DE PROCESAMIENTO ESG - PROTOCOLO NIERULA ET AL.
1. Resampling a 1000 Hz.
2. Detección de R-peaks (ECG).
3. PCA-OBS (4 componentes) sobre señal sin filtrar.
4. Filtro IIR Butterworth (4º orden) 5-400 Hz + Notch 50 Hz.
"""

import mne
import numpy as np
from pathlib import Path
from mne.preprocessing import apply_pca_obs
import gc

# ============================================================
# 1. CONFIGURACIÓN DE RUTAS
# ============================================================
BASE_DIR = Path(r"C:\Users\navar\Desktop\eeg\eeg")
# Buscamos todos los archivos que salieron del Script 2 (Re-referenciados)
INPUT_FILES = list(BASE_DIR.glob("*_RefTH6.fif"))
OUT_DIR = BASE_DIR / "ESG_CLEAN_OBS"
OUT_DIR.mkdir(exist_ok=True)

# Canales ESG para aplicar el OBS
ESG_CHANNELS = [
    "Iz", "SC1", "S3", "S4", "S5", "S6", "S7", "S8", "S9",
    "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "SC6"
]

def run_nierula_pipeline():
    for f_path in INPUT_FILES:
        print(f"\n--- PROCESANDO PROTOCOLO NIERULA: {f_path.name} ---")
        
        try:
            # A. Cargar RAW
            raw = mne.io.read_raw_fif(f_path, preload=True, verbose=False)
            
            # B. DOWNSAMPLING A 1000 Hz (Paso 1 Nierula)
            print("  -> Downsampling a 1000 Hz...")
            raw.resample(1000, verbose=False)
            
            # C. DETECCIÓN DE R-PEAKS (Sobre señal de 1000Hz sin filtrar)
            # find_ecg_events es robusto porque aplica filtros internos para detectar
            print("  -> Detectando latidos cardíacos...")
            if 'ECG' not in raw.ch_names:
                print(f"  ❌ Error: No hay canal ECG en {f_path.name}. Saltando...")
                continue
                
            ecg_events, _, _ = mne.preprocessing.find_ecg_events(raw, ch_name='ECG', verbose=False)
            qrs_times = ecg_events[:, 0] / raw.info['sfreq']
            print(f"  -> {len(qrs_times)} latidos encontrados.")

            # D. PCA-OBS (Cardiac Correction)
            # Se aplica ANTES del filtrado de la señal para no deformar el artefacto
            print("  -> Aplicando PCA-OBS (4 componentes)...")
            picks_esg = [raw.ch_names.index(ch) for ch in ESG_CHANNELS if ch in raw.ch_names]
            
            raw_clean = apply_pca_obs(
                raw,
                qrs_times=qrs_times,
                picks=picks_esg,
                n_components=4,
                verbose=False
            )
            
            # E. FILTRADO POST-OBS (Paso 2 Nierula: 5-400 Hz + Notch)
            print("  -> Filtrado IIR Butterworth (5-400 Hz) + Notch 50 Hz...")
            # Filtro Paso-banda IIR de 4º orden (Zero-phase por defecto en MNE)
            raw_clean.filter(l_freq=5.0, h_freq=400.0, 
                             method='iir', 
                             iir_params=dict(order=4, ftype='butter'), 
                             verbose=False)
            
            # Notch 48-53 Hz para la red eléctrica
            raw_clean.notch_filter(freqs=50.0, method='fir', verbose=False)

            # F. GUARDAR RESULTADO
            out_name = OUT_DIR / f"{f_path.stem}_Nierula_Clean.fif"
            raw_clean.save(out_name, overwrite=True, verbose=False)
            print(f"  ✅ Guardado: {out_name.name}")
            
            # Limpieza de memoria
            del raw, raw_clean
            gc.collect()
            
        except Exception as e:
            print(f"  ❌ Error procesando {f_path.name}: {e}")

if __name__ == "__main__":
    run_nierula_pipeline()
