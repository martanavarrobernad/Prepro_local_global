# -*- coding: utf-8 -*-
"""
STEP 3: ICA TRAINING (RESPECTING STEP 2 MARKS)
----------------------------------------------
Objetivo: Entrenar ICA usando las marcas de rechazo que el usuario YA HIZO en el Paso 2.
Clave del éxito:
  1. Filtro 1Hz (High-Pass) -> OBLIGATORIO para que la ICA defina bien los ojos.
  2. Interpolación PREVIA -> Para tener 64 canales.
  3. reject_by_annotation=True -> Usa tu limpieza del Paso 2.
"""

import mne
from mne.preprocessing import ICA
import pandas as pd
import numpy as np
from pathlib import Path
import gc

# =============================================================================
# CONFIGURACIÓN
# =============================================================================
SUBJECT_DIR = Path(r"C:\Users\navar\Desktop\eeg\eeg")
CSV_PATH = SUBJECT_DIR / "bad_channels_registry.csv"

# Usamos los archivos que YA LIMPIASTE en el paso 2
INPUT_SUFFIX = "_Step2_Inspected.vhdr"

# CONFIGURACIÓN CRÍTICA
ICA_L_FREQ = 1.0        # <--- ESTO ES LO QUE ARREGLA LA "ICA FATAL"
MONTAJE_GORRO = 'easycap-M1'
N_COMPONENTS = 20       # 20 componentes es más estable visualmente
METHOD = 'fastica'
RANDOM_STATE = 97

EXPECTED_EEG = [
    'Fp1', 'Fz', 'F3', 'F7', 'FT9', 'FC5', 'FC1', 'C3', 'T7', 'TP9', 
    'CP5', 'CP1', 'Pz', 'P3', 'P7', 'O1', 'Oz', 'O2', 'P4', 'P8', 
    'TP10', 'CP6', 'CP2', 'C4', 'T8', 'FT10', 'FC6', 'FC2', 'F4', 
    'F8', 'Fp2', 'AF7', 'AF3', 'AFz', 'F1', 'F5', 'FT7', 'FC3', 
    'C1', 'C5', 'TP7', 'CP3', 'P1', 'P5', 'PO7', 'PO3', 'POz', 
    'PO4', 'PO8', 'P6', 'P2', 'CPz', 'CP4', 'TP8', 'C6', 'C2', 
    'FC4', 'FT8', 'F6', 'AF8', 'AF4', 'F2', 'FCz', 'Cz'
]
AUX_CHANNELS = ['VEOG', 'HEOG', 'ECG']

# =============================================================================
# FUNCIONES
# =============================================================================
def get_bads_from_csv(filename, df_bads):
    # Intentamos buscar por el nombre del archivo actual
    row = df_bads[df_bads['run'] == filename]
    # Si no, buscamos por el nombre original (Step1)
    if row.empty:
        alt = filename.replace("_Step2_Inspected", "_Step1_Prep")
        row = df_bads[df_bads['run'] == alt]
    
    if not row.empty:
        bads_str = str(row['bad_channels'].iloc[0])
        if bads_str and bads_str.lower() != 'nan':
            return [ch.strip() for ch in bads_str.split(',') if ch.strip()]
    return []

# =============================================================================
# EJECUCIÓN
# =============================================================================
if not CSV_PATH.exists(): raise FileNotFoundError("Falta CSV.")

df_bads = pd.read_csv(CSV_PATH)
files = sorted(list(SUBJECT_DIR.glob(f"*{INPUT_SUFFIX}")))

print(f"--- ENTRENANDO ICA (Usando tus marcas del Paso 2) ---")
print(f"Archivos: {len(files)}")

# Lista para guardar los raws y concatenar (MEJOR OPCIÓN: ICA GLOBAL)
raw_list = []

for f_path in files:
    print(f"\n--> Cargando: {f_path.name}")
    
    # 1. CARGAR (Esto lee automáticamente las Annotations BAD_ del paso 2)
    raw = mne.io.read_raw_brainvision(f_path, preload=True, verbose=False)
    
    # 2. TIPOS Y MONTAJE
    ch_map = {}
    for ch in raw.ch_names:
        if ch in EXPECTED_EEG: ch_map[ch] = 'eeg'
        elif ch in AUX_CHANNELS: ch_map[ch] = 'misc'
        else: ch_map[ch] = 'misc'
    raw.set_channel_types(ch_map)
    raw.set_montage(mne.channels.make_standard_montage(MONTAJE_GORRO), on_missing='ignore')
    
    # 3. FILTRO 1Hz (CRÍTICO)
    # Esto elimina la deriva lenta sin afectar las marcas de tiempo
    raw.filter(l_freq=ICA_L_FREQ, h_freq=None, verbose=False)
    
    # 4. INTERPOLACIÓN (Desde CSV)
    # Necesitamos 64 canales sanos para que la ICA funcione bien
    bads_csv = get_bads_from_csv(f_path.name, df_bads)
    valid_bads = [ch for ch in bads_csv if ch in raw.ch_names]
    raw.info['bads'] = valid_bads
    
    if valid_bads:
        try: 
            raw.interpolate_bads(reset_bads=True, verbose=False, method='spline')
        except: 
            raw.interpolate_bads(reset_bads=True, verbose=False, method=dict(eeg='mean'))
            
    # 5. REFERENCIA PROMEDIO
    raw.set_eeg_reference('average', projection=False, verbose=False)
    
    raw_list.append(raw)

# --- CONCATENACIÓN Y ENTRENAMIENTO ---
print(f"\n[PROCESO] Concatenando {len(raw_list)} archivos para ICA Global...")
raw_global = mne.concatenate_raws(raw_list)
del raw_list
gc.collect()

print(f"[PROCESO] Entrenando ICA sobre {raw_global.times[-1]/60:.1f} minutos...")
print("          (Saltando automáticamente tus zonas BAD_)...")

ica = ICA(n_components=N_COMPONENTS, 
          method=METHOD, 
          random_state=RANDOM_STATE, 
          max_iter='auto')

# reject_by_annotation=True ES LA CLAVE:
# Usa las marcas 'BAD_' que vienen en el archivo .vmrk del paso 2
ica.fit(raw_global, reject_by_annotation=True, verbose=True)

# GUARDAR
out_name = SUBJECT_DIR / "GLOBAL_ica.fif"
ica.save(out_name, overwrite=True)

print("\n" + "="*50)
print(f"✅ ICA LISTA: {out_name.name}")
print("Esta ICA se ha entrenado ignorando el ruido que marcaste.")
print("="*50)
